'''Алгоритм Дейкстры
    Граф задан матрицей смежности.
    Считаем, что начало ребра - номер строки, конец - номер столбца.
    На пересечении можно ставить вес ребра.
    Для неориентированного графа матрица будет симметричной,
    для ориентированного - как раз выполняется соглащение выше.'''

def alg_dejkstra(graph, start):
    count_node = len(graph) #количество вершин
    INF = 10 ** 10
    distance = [INF] * count_node #массив, хранищий расстояния от наальной до соответствующей вершины (изначально все расстояния равны INF)
    distance[start] = 0 #расстояние от начала до самого себя равно 0
    valid_nodes = [False] * count_node #массив, хранящий информацию о том, просмотрена ли вершина (изнчально вершины не просмотрены)
    previous = [None] * count_node #массив, хранищий путь из вершин по которым получается минимальное расстояние (изначально вершин нет)
    min_dist = 0 #минимальное расстояние (изначально равно 0)
    min_node = start #вершина с минимальным расстоянием от начальной (изначально сама начальная вершина)
    neighbour = [] #список смежных вершин

    #заменяем несуществующие ребра максимальными значениями
    for i in range(count_node):
        for j in range(count_node):
            if graph[i][j] == 0:
                graph[i][j] = INF

    #выбираем соседей для каждой вершины графа
    for k in range(count_node):
        neighbour.append([])
        for l in range(count_node):
            if graph[k][l] != INF:
                neighbour[k].append(l)

    while min_dist < INF:   #пока есть ребра от вершины с минимальным расстоянием
        i = min_node #вершина становится вершиной с минимальным расстоянием
        valid_nodes[i] = True #и помечается просмотренной
     
        for j in neighbour[i]: #просмотр по расстояниям от i-той до всех вершин, связанных с ней
            #print(f'j={j}')
            if distance[i] + graph[i][j] < distance[j]: #если сумма расстояния от начальной до i-той вершины и расстояния между i-той и j-той верешинами меньше расстояния от начальной до j-той вершины
                distance[j] = distance[i] + graph[i][j] #обновляем расстояние до j-той вершины на меньшее
                previous[j] = i #предыдущей вершиной в пути для j-той вершины становится i-тая вершина
                #print(f'distance = {distance}, previous = {previous}')
        min_dist = INF #миинимальное расстояние становится INF, когда все ребра от i-той вершины просмотрены

        for i in range(count_node): #для всех вершин графа
            if not valid_nodes[i] and distance[i] < min_dist: #если вершина на просмотрена и расстояние до нее от начало меньше минимального
                min_dist = distance[i] #минимальное расстояние становится расстоянием до вершины i
                min_node = i #вершиной с минимальным расстоянием становится i-тая

    #возвращаем список предыдущих вершин и расстояния
    return previous, distance

def print_result(previous_nodes, dist, start_node, end_node):
    '''Вывод результата:
        На вход передается список предыдущих вершин, список расстояний, начальная вершина, конечная вершина
        Составляется путь из начальной вершины в конечную
        Выводится путь из вершин и расстояние между начальной и конечной вершинами'''
    path = []
    node = end_node
    while node != start_node:
        path.append(node)
        node = previous_nodes[node]
    path.append(start_node)
    print(
        f'Наиболее короткий путь из {start_node} в {end_node}: {path[::-1]}\nРасстояние: {dist[end_node]}'
    )
 
#Неориентированный граф с одинаковыми весами ребер
graph1 = [
    [0,1,0,0,1,0,0,0,1,0,0,0],
    [1,0,0,0,0,0,0,1,0,0,1,0],
    [0,0,0,1,0,0,1,0,0,1,0,1],
    [0,0,1,0,0,1,0,1,0,1,0,0],
    [1,0,0,0,0,0,1,0,0,0,0,0],
    [0,0,0,1,0,0,0,0,0,0,1,0],
    [0,0,1,0,1,0,0,1,0,0,0,0],
    [0,1,0,1,0,0,1,0,1,0,0,0],
    [1,0,0,0,0,0,0,1,0,0,0,1],
    [0,0,1,1,0,0,0,0,0,0,0,0],
    [0,1,0,0,0,1,0,0,0,0,0,0],
    [0,0,1,0,0,0,0,0,1,0,0,0]
]

#Неориетированный граф с разными весами ребер
graph2 = [
    [0,7,0,0,5,0,0,0,3,0,0,0],
	[7,0,0,0,0,0,0,4,0,0,10,0],
	[0,0,0,1,0,0,1,0,0,1,0,1],
	[0,0,1,0,0,8,0,5,0,2,0,0],
	[5,0,0,0,0,0,1,0,0,0,0,0],
	[0,0,0,8,0,0,0,0,0,0,5,0],
	[0,0,1,0,1,0,0,8,0,0,0,0],
	[0,4,0,5,0,0,8,0,7,0,0,0],
	[3,0,0,0,0,0,0,7,0,0,0,1],
	[0,0,1,2,0,0,0,0,0,0,0,0],
	[0,10,0,0,0,5,0,0,0,0,0,0],
	[0,0,1,0,0,0,0,0,1,0,0,0]
]

#Ориентированный граф с одинаковыми весами ребер
graph3 = [
    [0,1,0,0,0,0,0,0,0,0,0,0],
	[0,0,0,0,0,0,1,0,0,1,0,0],
	[0,0,0,1,0,0,0,0,1,0,1,0],
	[1,0,0,0,0,1,1,0,0,0,0,1],
	[0,0,1,0,0,0,0,1,0,1,0,0],
	[0,0,0,0,1,0,1,0,0,0,0,0],
	[0,0,1,0,0,0,0,1,0,0,0,0],
	[1,0,0,0,0,0,0,0,0,0,0,0],
	[0,1,0,0,1,0,0,0,0,0,0,0],
	[0,0,0,0,0,1,0,0,0,0,0,1],
	[1,0,0,0,0,0,0,0,0,1,0,0],
	[0,0,0,0,0,0,0,0,0,0,1,0]
]

#Ориентированный граф с разными весами ребер
graph4 = [
    [0,5,0,0,0,0,0,0,0,0,0,0],
	[0,0,0,0,0,0,7,0,0,3,0,0],
	[0,0,0,4,0,0,0,0,5,0,2,0],
	[1,0,0,0,0,1,5,0,0,0,0,9],
	[0,0,4,0,0,0,0,5,0,3,0,0],
	[0,0,0,0,1,0,2,0,0,0,0,0],
	[0,0,1,0,0,0,0,5,0,0,0,0],
	[10,0,0,0,0,0,0,0,0,0,0,0],
	[0,5,0,0,3,0,0,0,0,0,0,0],
	[0,0,0,0,0,5,0,0,0,0,0,1],
	[1,0,0,0,0,0,0,0,0,3,0,0],
	[0,0,0,0,0,0,0,0,0,0,5,0]
]

start = 3

previous_nodes, dist = alg_dejkstra(graph1, start)
print('Результат для первого графа:')
for node in range(len(graph1)):
        if node != start:
            print_result(
                previous_nodes,
                dist,
                start_node = start,
                end_node = node
            )

previous_nodes, dist = alg_dejkstra(graph2, start)
print('Результат для второго графа:')
for node in range(len(graph2)):
        if node != start:
            print_result(
                previous_nodes,
                dist,
                start_node = start,
                end_node = node
            )

previous_nodes, dist = alg_dejkstra(graph3, start)
print('Результат для третьего графа:')
for node in range(len(graph3)):
        if node != start:
            print_result(
                previous_nodes,
                dist,
                start_node = start,
                end_node = node
            )

previous_nodes, dist = alg_dejkstra(graph4, start)
print('Результат для четвертого графа:')
for node in range(len(graph4)):
        if node != start:
            print_result(
                previous_nodes,
                dist,
                start_node = start,
                end_node = node
            )

